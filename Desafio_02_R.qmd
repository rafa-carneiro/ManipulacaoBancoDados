---
title: "Laboratório 2"
subtitle: "Processamento de Bases de Dados em Lote"
author: "Rafael Gomes Caarneiro - RA185462"
format: html
editor: source
---

## **Introdução**

A coleta de dados em épocas mais recentes teve seu custo reduzido e volume ampliado significativamente. Redes sociais combinadas com dispositivos móveis rastreiam bilhões de pessoas no mundo, com informações das mais diversas origens: rotinas de passeio, amizades, históricos de compras, históricos de localização, fotografias geo-referenciadas, etc (FYI: com o escândalo da Cambridge Analytica, surgiram evidências de que o Facebook tenha registros de histórico de chamadas e SMS, para mensagem e ligações ocorridas fora do aplicativo Facebook, em telefones Android: <https://www.theverge.com/2018/3/25/17160944/facebook-call-history-sms-data-collection-android>). Empresas, por meio de programas de fidelidade, aprendem hábitos de compras, propensidade de compras de certos produtos dependendo de horários, produtos que são comprados juntos e informações financeiras referentes a pagamentos. Desta maneira, o volume das bases de dados cresce vertiginosamente, de modo que é necessária a mudança de paradigma na estatística moderna: os dados não mais podem trafegar até o analista de dados; a análise deve ser transportada até os dados.

## **Objetivos**

Ao fim deste laboratório, você deve ser capaz de:

-   Importar um arquivo volumoso por partes;

-   Calcular estatísticas suficientes para métrica de interesse em cada uma das partes importadas;

-   Manter em memória apenas o conjunto de estatísticas suficientes e utilizar a memória remanescente para execução de cálculos;

-   Combinar as estatísticas suficientes de modo a compor a métrica de interesse.

## **Tarefa (retirada dos últimos slides da última aula)**

Lendo 100.000 observações por vez (se você acredita que seu computador não tem memória suficiente, utilize 10.000 observações por vez), determine o percentual de vôos por Cia. Aérea que apresentou atraso na chegada (`ARRIVAL_DELAY`) superior a 10 minutos. As companhias a serem utilizadas são: AA, DL, UA e US. A estatística de interesse deve ser calculada para cada um dos dias de 2015. Para a determinação deste percentual de atrasos, apenas verbos do pacote `dplyr` e comandos de importação do pacote `readr` podem ser utilizados. Os resultados para cada Cia. Aérea devem ser apresentados em um formato de calendário.

Observação: a atividade descrita no slide pede para ler apenas 100 registros por vez. Aqui, mudamos para 100 mil registros por vez, para que haja melhor aproveitamento do tempo em classe.

## Pacotes Utilizados e Arquivos Baixados

```{r setup}
#| label: Pacotes Utilizados e Arquivos Baixados
#| include: false

library(readr)
library(dplyr)
library(tictoc)
library(lubridate)  
library(tibble)
library(ggcal)
library(ggplot2)
```

## **Instruções**

1.  Quais são as estatísticas suficientes para a determinação do percentual de vôos atrasados na chegada (`ARRIVAL_DELAY > 10`)?

    A estatíticas suficientes para determinar o percentual de vôos atrasados seriam os dados de datas: `YEAR`, `MONTH`, `DAY`. E as linhas de vôos, que seria a `AIRLINE`.

2.  Crie uma função chamada `getStats` que, para um conjunto de qualquer tamanho de dados provenientes de `flights.csv.zip`, execute as seguintes tarefas (usando apenas verbos do `dplyr`):

    a.  Filtre o conjunto de dados de forma que contenha apenas observações das seguintes Cias. Aéreas: AA, DL, UA e US;

    b.  Remova observações que tenham valores faltantes em campos de interesse;

    c.  Agrupe o conjunto de dados resultante de acordo com: dia, mês e cia. aérea;

    d.  Para cada grupo em b., determine as estatísticas suficientes apontadas no item 1. e os retorne como um objeto da classe `tibble`;

    e.  A função deve receber apenas dois argumentos:

        1.  `input`: o conjunto de dados (referente ao lote em questão);

        2.  `pos`: argumento de posicionamento de ponteiro dentro da base de dados. Apesar de existir na função, este argumento não será empregado internamente. **É importante** observar que, sem a definição deste argumento, será impossível fazer a leitura por partes.

    ```{r}
    getStats <- function(input, pos){
      input %>% 
        filter(AIRLINE %in% c("AA", "DL", "UA", "US"), # Companias desejadas
               !is.na(ARRIVAL_DELAY),
               !is.na(YEAR),
               !is.na(MONTH),
               !is.na(DAY)) %>% # Remover os "NA"
        
        group_by(YEAR, MONTH, DAY, AIRLINE) %>% # Agrupamento
        
        summarise(
          n_total = n(),
          n_atrasados = sum(ARRIVAL_DELAY > 10),
          .groups = "drop"
        ) %>%
        
        as_tibble()
    }
    ```

3.  Utilize alguma função `readr::d_***_chunreaked` para importar o arquivo `flights.csv.zip`.

    1.  Configure o tamanho do lote (chunk) para 100 mil registros;

    2.  Configure a função de *callback* para instanciar DataFrames aplicando a função `getStats` criada acima;

    3.  Configure o argumento `col_types` de forma que ele leia, diretamente do arquivo, apenas as colunas de interesse (veja nota de aula para identificar como realizar esta tarefa);

    ```{r}
    tic()

      # === Callback para cada chunk ===
      processa_chunk <- function(x, pos) { 
        df <- getStats(x)  # aplica a função no lote
        return(df)         # precisa devolver um data.frame/tibble
      }
      
      dados_recortados <- read_csv_chunked(
        '../dados/flights.csv.zip',
        callback = DataFrameCallback$new(processa_chunk),
        chunk_size = 100000,
        col_types = cols_only(
          AIRLINE = 'c',
          ARRIVAL_DELAY = 'i',
          YEAR = 'i',
          MONTH = 'i',
          DAY = 'i'
        )
      )
      
    toc()
    ```

    ```{r}
    tic()
    # === Resultado final: consolidar todos os chunks ===
      resultado_final <- dados_recortados %>% 
        group_by(YEAR, MONTH, DAY, AIRLINE) %>% 
        summarise(
          n_total = sum(n_total),
          n_atrasados = sum(n_atrasados),
          .groups = "drop"
        )
      
      head(resultado_final)
      
    toc() 
    ```

4.  Crie uma função chamada `computeStats` que:

    1.  Combine as estatísticas suficientes para compor a métrica final de interesse (percentual de atraso por dia/mês/cia aérea);

    2.  Retorne as informações em um `tibble` contendo apenas as seguintes colunas:

        1.  `Cia`: sigla da companhia aérea;

        2.  `Data`: data, no formato AAAA-MM-DD (dica: utilize o comando `as.Date`);

        3.  `Perc`: percentual de atraso para aquela cia. aérea e data, apresentado como um número real no intervalo \[0,1\].

    ```{r}
    tic()

    computeStats <- function(df_stats) {
      df_stats %>%
        mutate(
          Cia = AIRLINE,                             # renomeia a coluna
          Data = as.Date(paste(YEAR, MONTH, DAY, sep = "-")),  # cria data no formato AAAA-MM-DD
          Perc = n_atrasados/n_total               # calcula percentual de atraso
        ) %>%
        select(Cia, Data, Perc) %>%                  # mantém apenas as colunas desejadas
        as_tibble()
    }
    dados_tibble <- computeStats(resultado_final)
    head(dados_tibble)

    toc()
    ```

5.  Produza um mapa de calor em formato de calendário para cada Cia. Aérea.

    1.  Instale e carregue os pacotes `ggcal` e `ggplot2`.

    2.  Defina uma paleta de cores em modo gradiente. Utilize o comando `scale_fill_gradient`. A cor inicial da paleta deve ser `#4575b4` e a cor final, `#d73027`. A paleta deve ser armazenada no objeto `pal`.

    3.  Crie uma função chamada `baseCalendario` que recebe 2 argumentos a seguir: `stats` (`tibble` com resultados calculados na questão 4) e `cia` (sigla da Cia. Aérea de interesse). A função deverá:

        1.  Criar um subconjunto de `stats` de forma a conter informações de atraso e data apenas da Cia. Aérea dada por `cia`.

        2.  Para o subconjunto acima, montar a base do calendário, utilizando `ggcal(x, y)`. Nesta notação, `x` representa as datas de interesse e `y`, os percentuais de atraso para as datas descritas em `x`.

        3.  Retornar para o usuário a base do calendário criada acima.

    4.  Executar a função `baseCalendario` para cada uma das Cias. Aéreas e armazenar os resultados, respectivamente, nas variáveis: `cAA`, `cDL`, `cUA` e `cUS`.

    5.  Para cada uma das Cias. Aéreas, apresente o mapa de calor respectivo utilizando a combinação de camadas do `ggplot2`. Lembre-se de adicionar um título utilizando o comando `ggtitle`. Por exemplo, `cXX + pal + ggtitle("Titulo")`.

    ```{r}
    # =================== #
    # Pacotes Necessários #
    # =================== #
    library(ggcal)
    library(ggplot2) 

    tic()

    # ============================================ #
    # Definir paleta de cores para o mapa de calor #
    # ============================================ #
    pal <- scale_fill_gradient(low = "#4575b4", high = "#d73027")

    # ==================================== #
    # Função para criar base de calendário #
    # ==================================== #
    baseCalendario <- function(stats, cia) {
      df_cia <- stats %>% filter(Cia == cia)
      cal_base <- ggcal(df_cia$Data, df_cia$Perc)
      return(cal_base)
    }

    # =============================== #
    # Gerar calendários por companhia #
    # =============================== #
    cAA <- baseCalendario(dados_tibble, "AA")
    cDL <- baseCalendario(dados_tibble, "DL")
    cUA <- baseCalendario(dados_tibble, "UA")
    cUS <- baseCalendario(dados_tibble, "US")

    cAA + pal + ggtitle("Mapa de calor - AA") 

    toc()

    ```
